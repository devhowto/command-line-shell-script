= Bash Redirection
:page-subtitle: Command Line and Shell Script

== Intro

Redirection is all about _file descriptors (FD for short):

* Standard input, or STDIN is FD 0.
* Standard output, or STDOUT is FD 1.
* Standard error, or STDERR is FD 2.

On most Unix systems, we have:

* `/dev/stdin`
* `/dev/stdout`
* `/dev/stderr`

Shells offer shorthand syntax to work with those devices and file descriptors.

Programs can read input from STDIN or other sources, as well as send output to both STDOUT, STDERR or other destinations, like log files.
A well-designed, well-written program will send output to whatever destination is makes sense allowing a more fine-grained control users trying to filer and read the program's output.

Many (if not all) standard Unix and/or GNU tools send normal messages to STDOUT and error messages to STDERR.

When programs send messages to STDERR, they show up in the terminal as if they were standard, normal messages, but that is because shells attach both STDOUT and STDERR to the terminal so we can read messages, be them errors or not.

For example, if we run the command `nope`, and such command (program) cannot be found, the shell informs you about it:

[source,shell-session]
----
$ nope
-bash: nope: command not found
----

That message is STDERR, but we see it in STDOUT (because by default, the shell attaches both STDOUT and STDERR to the terminal).

And we can redirect any error message (FD2) to the `/dev/null` black hole, a log file, or some other thing.
Read on.

== Redirect STDERR

First, let's run a command that doesn't exist:

[source,shell-session]
----
$ nope
-bash: nope: command not found
----

If that message was sent to STDERR, we can redirect it, for instance, to `/dev/null` to ignore it:

[source,shell-session]
----
$ nope 2> /dev/null
(no output)
----

Or to a file for later inspection:

[source,shell-session]
----
$ nope 2> ./err.txt
(no output)

$ cat ./err.txt
bash: nope: command not found
----

Run `ls` on a non-existing file, which will print an error message:

[source,shell-session]
----
$ ls ./i-dont-exist
ls: cannot access './i-dont-exist': No such file or directory
----

If `ls` sends error messages to STDERR (which it does), then we can redirect that message to whatever destination we see fit.
If we don't want to display the error, but instead send it to the black hole, we then send STDERR (file descriptor 2) to `/dev/null`:

[source,shell-session]
----
$ ls ./i-dont-exist 2> /dev/null
----

Or to a log file:

[source,shell-session]
----
$ ls ./i-dont-exist 2> ./err.log
(no output)
$ cat ./err.log
ls: cannot access './i-dont-exist': No such file or directory
----

And the redirection `2> destination` part does not need to came last.
It just feels more natural to write it last, but it can be even written before the command itself:

[source,shell-session]
----
$ 2> ./err.txt nope
(no output)
$ cat ./err.txt
bash: nope: command not found

$ 2> ./err.log ls ./i-dont-exist
(no output)
$ cat ./err.log
ls: cannot access './i-dont-exist': No such file or directory
----

== Redirect all messages to /dev/null

Sometimes we just want the terminal to be silent and not pollute the output with noise that may not matter for a given situation and ends up taking our attention away from whatever we are doing.
See here one example:

image::emacs-stdout-stderr-1.png[bash emacs stdout sterr]

[NOTE]
====
I do not advise hiding terminal messages in general, but sometimes it may be desirable for specific situations.
====

I just want to open emacs on my `little-schemer` directory to work on the exercise of the book The Little Schemer, but those messages annoy and distract me.

For bash >= 4, we can simply do:

.redir stderr and stdout to /dev/null, bash >= 4 only
[source,shell-session]
----
$ emacs ./main.scm &> /dev/null &
----

Of course one may prefer to redirect to a text file instead:

.redir stderr and stdout to text file
[source,shell-session]
----
$ emacs ./main.scm &> ./log.txt &
----

Note we used `&>`.
`For bash < 4 or other shells, this is a more portable approach is to use the more standard `2>&1`:

.redir stderr and stdout to /dev/null, portable
[source,shell-session]
----
$ emacs ./defs.scm > /dev/null 2>&1 &
----

Or

.redir stderr and stdout to text file, portable
[source,shell-session]
----
$ emacs ./defs.scm > ./out.txt 2>&1 &
----

Note we first `> /dev/null` then we redirect STDERR to STDOUT with `2>&1`.

In all cases, the final `&` is used to free the prompt as the process then is run in the background.

== References

* link:https://www.gnu.org/software/bash/manual/html_node/Redirections.html[GNU Bash Redirections online manual^].

